---
layout: page
title: Коллекции
category: basics
order: 2
lang: ru
---

Списки, туплы, ключевые списки, мапы, словари и функциональные комбинаторы.

## Содержание

- [Списки](#lists)
  - [Обьединение списков](#list-concatenation)
  - [Вычитание списков](#list-subtraction)
  - [Голова / Хвост](#head--tail)
- [Туплы](#tuples)
- [Ключевые списки](#keyword-lists)
- [Мапы](#maps)

## Списки
Списки - это обычные коллекции значений. Они могут включать различные типы и неуникальные значения.

```elixir
iex> [3.41, :pie, "Apple"]
[3.41, :pie, "Apple"]
```

Elixir имплементирует списки как связанные списки (linked list). Это означает что сложность получения длины списка имеет сложность `O(n)`. По этой причине намного быстрее добавлять новые элементы в начало списка, чем в конец.

```elixir
iex> list = [3.41, :pie, "Apple"]
[3.41, :pie, "Apple"]
iex> ["π"] ++ list
["π", 3.41, :pie, "Apple"]
iex> list ++ ["Cherry"]
[3.41, :pie, "Apple", "Cherry"]
```

### Обьединение списков

Для обьединения списков используется оператор `++/2`:

```elixir
iex> [1, 2] ++ [3, 4, 1]
[1, 2, 3, 4, 1]
```

### Вычитание списков

Оператор `--/2` предоставляет возможность вычитать списки. Не будет ошибкой удаление отсутствующего элемента:

```elixir
iex> ["foo", :bar, 42] -- [42, "bar"]
["foo", :bar]
```

### Голова / Хвост

При использовании списков очень частой операцией является получение начала и "хвоста" списка. "Головой" является первый элемент, а "хвостом" - остальные элементы. Elixir предоставляет два оператора `hd` и `tl` для работы с этими частями:

```elixir
iex> hd [3.41, :pie, "Apple"]
3.41
iex> tl [3.41, :pie, "Apple"]
[:pie, "Apple"]
```

Кроме этого, того же результата можно добиться с использованием оператора `|`. Мы его часто встретим в последующих уроках.

```elixir
iex> [h|t] = [3.41, :pie, "Apple"]
[3.41, :pie, "Apple"]
iex> h
3.41
iex> t
[:pie, "Apple"]
```

## Туплы

Туплы похожи на списки, но хранятся в памяти последовательно. Это дает возможность быстро получать определенный элемент и длину тупла. Но изменения становятся "дорогими", так как для этого создаваемый тупл должен быть целиком скопирован в новую область памяти. Туплы определяются с помощью фигурных скобок:

```elixir
iex> {3.41, :pie, "Apple"}
{3.41, :pie, "Apple"}
```

Часто они используются как механизм для получения дополнительной информации из функций. Полезность этого будет видна позже, когда мы будем углублятся в pattern matching:

```elixir
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}
iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

## Ключевые списки

Ключи и мапы являются ассоциативными коллекциями в Elixir. Они оба имплементируют модуль `Dict`. В Elixir ключевой список - это специальный список из туплов, первым элементов которых является атом. По скорости они идентичны спискам.

```elixir
iex> [foo: "bar", hello: "world"]
[foo: "bar", hello: "world"]
iex> [{:foo, "bar"}, {:hello, "world"}]
[foo: "bar", hello: "world"]
```

Три характеристики этой структуры данных показывают ее важность:

+ Ключи являются атомами.
+ Ключи имеют свой порядом.
+ Ключи неуникальны.

По этой причине она часто используется для передачи параметров в функции.

## Мапы

В Elixir мапы это хранилище типа ключ-значение с возможностью быстрого получения информации по ключу. В отличие от ключевых списков они поддерживают любой тип ключей и не сохраняют порядок следования. Они обьявляются с помощью синтаксиса `%{}`:

```elixir
iex> map = %{:foo => "bar", "hello" => :world}
%{:foo => "bar", "hello" => :world}
iex> map[:foo]
"bar"
iex> map["hello"]
:world
```

С версии Elixir 1.2 переменные поддерживаются в качестве ключей мапов:

```elixir
iex> key = "hello"
"hello"
iex> %{key => "world"}
%{"hello" => "world"}
```

Если в эту структуру данных добавляется новый ключ, он перепишет старое значение:

```elixir
iex> %{:foo => "bar", :foo => "hello world"}
%{foo: "hello world"}
```

Как видно из вывода команды выше, также есть специальный короткий синтаксис для мапов, ключами которых являются только атомы:

```elixir
iex> %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}

iex> %{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}
true
```
