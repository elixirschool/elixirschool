%{
  version: "0.9.0",
  title: "Enum",
  excerpt: """
  Набор от алгоритми за изброяване върху колекции.
  """
}
---

## Enum

`Enum` модулът съдържа над сто функции за работа с колекции, за които учихме предният урок.

Този урок ще покрие само част от достъпните функции, за да видите пълния набор от функции, посетете официалните [`Enum`](https://hexdocs.pm/elixir/Enum.html) документи; за lazy изброяване използвайте модула [`Stream`](https://hexdocs.pm/elixir/Stream.html).


### all?

Когато използваме `all?`, и голяма част от `Enum`, ние предоставяме функция, която да бъде приложена върху елементите на колекцията ни.  В случая с `all?`, функцията трябва да върне `true` за вески един елемент от колекцията, в противен случай връща `false`:

```elixir
iex> Enum.all?(["foo", "bar", "hello"], fn(s) -> String.length(s) == 3 end)
false
iex> Enum.all?(["foo", "bar", "hello"], fn(s) -> String.length(s) > 1 end)
true
```

### any?

За разлика от предходното, `any?` ще върне `true` ако поне един елемент е оценен като `true`:

```elixir
iex> Enum.any?(["foo", "bar", "hello"], fn(s) -> String.length(s) == 5 end)
true
```

### chunk_every

Ако се нуждаете да разбиете колекцията си на по-малки групи, то `chunk_every/2` е функцията, която най-вероятно търсите:

```elixir
iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 2)
[[1, 2], [3, 4], [5, 6]]
```

Съществуват няколко опции за `chunk_every/2`, но няма да навлизаме в тях, вижте [`chunk_every/4`](https://hexdocs.pm/elixir/Enum.html#chunk_every/4) в официалните документи, за да научите повече.

### chunk_by

Ако се нуждаете да групирате колекцията си на базата на нещо друго освен размер може да използвате метода `chunk_by`. Той приема подаден обходим елемент и функция и когато върната стойност от тази фунцкия се промени, започва нова група:

```elixir
iex> Enum.chunk_by(["one", "two", "three", "four", "five"], fn(x) -> String.length(x) end)
[["one", "two"], ["three"], ["four", "five"]]
iex> Enum.chunk_by(["one", "two", "three", "four", "five", "six"], fn(x) -> String.length(x) end)
[["one", "two"], ["three"], ["four", "five"], ["six"]]
```

### each

Може да е нужно да итерирате през колекция, без да издавате нова стойност, като в този случй се използва `each`:

```elixir
iex> Enum.each(["one", "two", "three"], fn(s) -> IO.puts(s) end)
one
two
three
:ok
```

__Забележка__: Методът `each` връща атома `:ok`.

### map

За да приложим нашата функция върху всеки елемент и получим нова колекция, прегледайте функцията `map`:

```elixir
iex> Enum.map([0, 1, 2, 3], fn(x) -> x - 1 end)
[-1, 0, 1, 2]
```

### min

Намери минималната(`min`) стойност в нашата колекцията:

```elixir
iex> Enum.min([5, 3, 0, -1])
-1
```

### max

Връща максималната(`max`) стойност в колекцията:

```elixir
iex> Enum.max([5, 3, 0, -1])
5
```

### reduce

Чрез `reduce` може да редуцираме колекцията си до една единствена стойност.  За да направим това подаваме опционален акумулатор (`10` в този пример), който да бъде подаден в нашата функция; ако няма подаден акумулатор се използва първата стойност:

```elixir
iex> Enum.reduce([1, 2, 3], 10, fn(x, acc) -> x + acc end)
16
iex> Enum.reduce([1, 2, 3], fn(x, acc) -> x + acc end)
6
iex> Enum.reduce(["a","b","c"], "1", fn(x,acc)-> x <> acc end)
"cba1"
```

### sort

Да сортираме нашите колекции е улеснено не чрез една, а две `sort` функции.  Първата достъпна за нас използва подредбата на термини на Elixir, за да установи сортираният ред:

```elixir
iex> Enum.sort([5, 6, 1, 3, -1, 4])
[-1, 1, 3, 4, 5, 6]

iex> Enum.sort([:foo, "bar", Enum, -1, 4])
[-1, 4, Enum, :foo, "bar"]
```

Другата опция ни позволява да подадем сортираща функция:

```elixir
# с нашата функция
iex> Enum.sort([%{:val => 4}, %{:val => 1}], fn(x, y) -> x[:val] > y[:val] end)
[%{val: 4}, %{val: 1}]

# без
iex> Enum.sort([%{:count => 4}, %{:count => 1}])
[%{count: 1}, %{count: 4}]
```

### uniq

Може да ползваме `uniq`, за да премахнем повтарящите се елементи от нашите колекции:

```elixir
iex> Enum.uniq([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])
[1, 2, 3, 4]
```
