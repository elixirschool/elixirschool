%{
  version: "1.2.0",
  title: "Αλφαριθμητικά",
  excerpt: """
  Αλφαριθμητικά, Χαρακτήρες Λιστών, Γραφήματα και Κωδικοσημεία.
  """
}
---

## Αλφαριθμητικά

Τα αλφαριθμητικά στην Elixir δεν είναι τίποτα άλλο από αλληλουχία bytes.
Ας δούμε ένα παράδειγμα:

```elixir
iex> string = <<104,101,108,108,111>>
"hello"
iex> string <> <<0>>
<<104, 101, 108, 108, 111, 0>>
```

Ενώνοντας το αλφαριθμητικό με το byte `0`, το IEx εμφανίζει το αλφαριθμητικό σαν ένα διαδικό επειδή δεν είναι έγκυρο αλφαριθμητικό πια.
Το κόλπο αυτό μπορεί να μας βοηθήσει να δούμε τα bytes που απαρτίζουν κάθε αλφαριθμητικό.

>Σημείωση: Η χρήση του συντακτικού << >> δηλώνει στο μεταγλωττιστή ότι τα στοιχεία μέσα σε αυτά τα σύμβολα είναι bytes.

## Λίστες Χαρακτήρων

Εσωτερικά, τα αλφαριθμητικά στην Elixir αναπαριστώνται με μια αλληλουχία bytes αντί ενός πίνακα χαρακτήρων.
Η Elixir επίσης έχει έναν τύπο λίστας χαρακτήρων.
Τα αλφαριθμητικά στην Elixir περικλείονται από διπλά εισαγωγικά, ενώ οι λίστες χαρακτήρων με μονά.

Ποιά η διαφορά; Κάθε τιμή στη λίστα χαρακτήρων είναι το κωδικοσημείο Unicode ενός χαρακτήρα, ενώ στο διαδικό, τα κωδικοσημεία είναι κωδικοποιημένα σαν UTF-8.
Πιο αναλυτικά:

```elixir
iex(5)> 'hełło'
[104, 101, 322, 322, 111]
iex(6)> "hełło" <> <<0>>
<<104, 101, 197, 130, 197, 130, 111, 0>>
```

Το `322` είναι το κωδικοσημείο Unicode για τον χαρακτήρα ł αλλά είναι κωδικοποιημένο στο UTF-8 σαν τα δύο byte `197` και `130`.

Μπορείτε να δείτε το κωδικοσημείο ενός χαρακτήρα με τη χρήση του `?`

```elixir
iex> ?Z
90
```

Αυτό σας επιτρέπει να χρησιμοποιήσετε το συντακτικό `?Z` αντί του `Z` για ένα σύμβολο.

Όταν προγραμματίζουμε στην Elixir, συνήθως χρησιμοποιούμε Αλφαριθμητικά, όχι λίστες χαρακτήρων.
Η υποστήριξη για λίστες χαρακτήρων υπάρχει επειδή χρειάζεται σε μερικές ενότητες της Erlang.

Για περισσότερες πληροφορίες, δείτε στην επίσημη τεκμηρίωση το [`Getting Started Guide`](http://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html).

## Γραφήματα και Κωδικοσημεία

Τα κωδικοσημεία είναι απλά χαρακτήρες Unicode, οι οποίοι μπορεί να αναπαριστώνται από ένα ή δύο bytes, ανάλογα την κωδικοποίηση του UTF-8.
Οι χαρακτήρες εκτός του σετ χαρακτήρων US ASCII θα κωδικοποιούνται πάντα σε παραπάνω από ένα byte.
Για παράδειγμα, οι λατινικοί χαρακτήρες με περισπωμένη ή τόνους ( `á, ñ, è, ά`) τυπικά κωδικοποιούνται σαν δύο bytes.
Οι χαρακτήρες από τις Ασιατικές γλώσσες συχνά κωδικοποιούνται σαν τρία ή τέσσερα bytes.
Τα γραφήματα αποτελούνται από πολλαπλά κωδικοσημεία που εμφανίζονται σαν ένας απλός χαρακτήρας.

Η ενότητα Αλφαριθμητικών (String) παρέχει δύο μεθόδους για την παραγωγή τους, τις `graphemes/1` και `codepoints/1`.
Ας δούμε ένα παράδειγμα:

```elixir
iex> string = "\u0061\u0301"
"á"

iex> String.codepoints string
["a", "́"]

iex> String.graphemes string
["á"]
```

## Συναρτήσεις Αλφαριθμητικών

Ας δούμε μερικές από τις πιο σημαντικές και χρήσιμες συναρτήσεις της ενότητας String.
Αυτό το μάθημα θα καλύψει ένα υποσύνολο των διαθέσιμων συναρτήσεων.
Για να δείτε το πλήρες σετ συναρτήσεων επισκεφθείτε τα επίσημα έγγραφα της [`String`](https://hexdocs.pm/elixir/String.html).

### `length/1`

Επιστρέφει το σύνολο των Γραφημάτων στο αλφαριθμητικό.

```elixir
iex> String.length "Γεια"
4
```

### `replace/3`

Επιστρέφει ένα νέο αλφαριθμητικό αντικαθιστώντας ένα τρέχον πρότυπο στο αλφαριθμητικό με ένα αλφαριθμητικο αλλαγής.

```elixir
iex> String.replace("Hello", "e", "a")
"Hallo"
```

### `duplicate/2`

Επιστρέφει ένα νέο αλφαριθμητικό επαναλαμβανόμενο n φορές.

```elixir
iex> String.duplicate("Ωχ αμάν ", 3)
"Ωχ αμάν Ωχ αμάν Ωχ αμάν "
```

### `split/2`

Επιστρέφει μία λίστα αλφαριθμητικών χωρισμένη από ένα πρότυπο.

```elixir
iex> String.split("Γεια σου κόσμε", " ")
["Γειά", "σου", "κόσμε"]
```

## Ασκήσεις

Ας δούμε μερικές απλές ασκήσεις για να αποδείξουμε ότι είμαστε έτοιμοι με τα αλφαριθμητικά!

### Αναγραματισμοί

Το Α και το Β θεωρούνται αναγραμματισμοί αν υπάρχει ένας τρόπος να αλλάξουμε το Α και το Β κάνοντάς τα ίσα.
Για παράδειγμα:

+ Α = τεστ
+ B = τσετ

Αν αλλάξουμε σειρά στους χαρακτήρες του αλφαριθμητικού Α, θα πάρουμε το αλφαριθμητικό Β και αντίστροφα.

Οπότε, πως θα μπορούσαμε να ελέγξουμε αν δύο αλφαριθμητικά είναι Αναγραμματισμοί στην Elixir;Η πιό εύκολη λύση είναι να ταξινομήσουμε τα γραφήματα κάθε αλφαριθμητικού αλφαβητικά και να ελέγξουμε αν και οι δύο λίστες είναι ίσες.
Ας το δοκιμάσουμε:

```elixir
defmodule Anagram do
  def anagrams?(a, b) when is_binary(a) and is_binary(b) do
    sort_string(a) == sort_string(b)
  end

  def sort_string(string) do
    string
    |> String.downcase()
    |> String.graphemes()
    |> Enum.sort()
  end
end
```

Ας δούμε πρώτα την `anagrams/2`.
Ελέγχουμε αν οι παράμετροι που δεχόμαστε είναι δυαδικές ή όχι.
Αυτός είναι ο τρόπος να ελέγξουμε αν η παράμετρος είναι αλφαριθμητικό στην Elixir.

Μετά από αυτό, καλούμε μια συνάρτηση η οποία ταξινομεί τα αλφαριθμητικά σε αλφαβητική σειρά.
Πρώτα μετατρέπει το αλφαριθμητικό σε μικρά και μετά χρησιμοποιεί την `String.graphemes`, η οποία επιστρέφει μια λίστα με τα Γραφήματα του αλφαριθμητικού.
Τελικά, μεταφέρει τη λίστα αυτή στην `Enum.sort/1`.
Πολύ εύκολο, έτσι;

Ας δούμε την έξοδο στο iex:

```elixir
iex> Anagram.anagrams?("Γειά", "άιεγ")
true

iex> Anagram.anagrams?("Μαρία", "ίΜαρα")
true

iex> Anagram.anagrams?(3, 5)
** (FunctionClauseError) no function clause matching in Anagram.anagrams?/2

    The following arguments were given to Anagram.anagrams?/2:

        # 1
        3

        # 2
        5

    iex:11: Anagram.anagrams?/2
```

Όπως βλέπετε, η τελευταία κλήση στην `anagrams?` προξένησε ένα FunctionClauseError.
Αυτό το σφάλμα μας λέει ότι δεν υπάρχει συνάρτηση στην ενότητά μας με το πρότυπο δύο μη-δυαδικών παραμέτρων, και αυτό είναι ακριβώς που θέλουμε, να δεχτούμε δύο αλφαριθμητικά και τίποτα άλλο.
