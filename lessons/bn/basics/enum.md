%{
  version: "1.0.1",
  title: "ইনাম",
  excerpt: """
  কালেকশন এ ইনামুরেট এর সুবিধা নিবার  জন্য কিছু এলগোরিদম ।
  """
}
---

## ইনাম `Enum`

ইনাম `Enum` মডিউলে প্রায় ১০০ টার উপরে ফাংশন আছে যা দিয়ে কালেকশন এর সাথে কাজ করা যায় এবং এই ব্যাপারে আমরা এর আগের চ্যাপ্টারে কথা বলেছি।

এই চ্যাপ্টারে আমারা শুধু অল্প কিছু ফাংশন নিয়ে আলোচনা করবো । এবং বাকি ফাংশন গুলো আমরা নিজেরা পরে দেখে নিতে পারবো।

তাহলে, আসুন আমরা IEx নিয়ে ছোট একটা পরীক্ষা শুরু করি ।

```elixir
iex
iex> Enum.__info__(:functions) |> Enum.each(fn({function, arity}) ->
...>   IO.puts "#{function}/#{arity}"
...> end)
all?/1
all?/2
any?/1
any?/2
at/2
at/3
...
```

এই কাজটি করে আমরা নিজেরা এতক্ষণে নিশ্চয়ই বুঝতে পেরেছি যে , আমদের সামনে আসলে অসংখ্য ফাংশন আছে। আর এটি হয়েছে কারণ হল যে Enumeration হল ফাংশনাল প্রোগ্রামিং এর একেবারে মূল একটা বিষয় আর আসলেই এর ব্যাবহারের ক্ষেত্র ও বিশাল।

Elixir এর আরও সব সুবিধা গুলোর সাথে যদি আমরা এর সঠিক সমন্বয় করে ব্যাবহার করতে পারি তাহলে আমরা ডেভেলপার হিসাবে এর অনেক সহজেই অনেক বেশি সুবিধা পাব। আমরা এমনটা এর মধ্যে এরই ভিতর দেখতে পারলাম ডকুমেন্ট ইনফো এর মাধ্যমে।

ইনাম এর ফাংশন গুলোর পুরো লিস্ট দিখবার জন্য , আপনি যেতে পারেন ,[`Enum`](https://hexdocs.pm/elixir/Enum.html) ডকুমেন্ট এ, আর lazy enumeration ব্যাবহার করে,  [`Stream`](https://hexdocs.pm/elixir/Stream.html) মডিউল।

### all?

যখন আমরা `all?` ব্যাবহার করি `Enum` এর সাথেে। আসলে এই সময় আমরা কালেকশন এর আইটেম গুলির সাথে একটা ফাংশন এপ্লাই করি । এক্ষেত্রে মূলোতো `all?` এর জন্য কালেকশন ফলাফল দেয় , `true` বা `false` এ ।  

```elixir
iex> Enum.all?(["foo", "bar", "hello"], fn(s) -> String.length(s) == 3 end)
false
iex> Enum.all?(["foo", "bar", "hello"], fn(s) -> String.length(s) > 1 end)
true
```

### any?

আবার, উপরের মতন এই `any?` ফলাফল `true` রিটার্ন করে যদি শুধুমাত্র একটি ও আইটেম এর ফলাফল `true` হয় ।

```elixir
iex> Enum.any?(["foo", "bar", "hello"], fn(s) -> String.length(s) == 5 end)
true
```

### chunk_every

যদি কালেকশনকে ভেঙ্গে ছোট গ্রুপ তৈরি করতে হয় তাহলে, `chunk_every/2` ফাংশনটি ই আপনার দরকার।

```elixir
iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 2)
[[1, 2], [3, 4], [5, 6]]
```

`chunk_every/2` এর আরও কিছু অপশন আছে, কিন্তু আমরা সেগুলোতে আমরা এখন নাই যাই, আপনারা সেগুলো দেখে নিতে পারবেন এখানে,[`chunk_every/4`](https://hexdocs.pm/elixir/Enum.html#chunk_every/4) এই অফিসিয়াল ডকুমেন্ট এ ।

### chunk_by

যদি আমরা কালেকশনকে সাইজ ছাড়া অন্য কিছুর উপর ভিত্তি করে ছোট গ্রুপ এ ভাগ করতে চাই তাহলে আমরা `chunk_by/2` মেথড টি ব্যাবহার করতে পারি। এটি একটি ইনাম এবং ফাংশন এ কাজ করে কালেকশন কে ক্রমান্বয়ে ছোট ছোট গ্রুপে ভাগ করে।

```elixir
iex> Enum.chunk_by(["one", "two", "three", "four", "five"], fn(x) -> String.length(x) end)
[["one", "two"], ["three"], ["four", "five"]]
iex> Enum.chunk_by(["one", "two", "three", "four", "five", "six"], fn(x) -> String.length(x) end)
[["one", "two"], ["three"], ["four", "five"], ["six"]]
```

### map_every

কখনো কখনো দেখা যায় যে শুধু মাত্র কালেকশন কে ছোট গ্রুপ এ ভাগ করে কাজ শেষ হয় না । এরকম সময় , `map_every/3` একটি দারুণ ফাংশন কারণ এটি শুধু নির্ধারিত একটা আইটেম কে হিট করবে যদি কালেকশন এ সেরকম অরডারিং থাকে এবং দরকার হয়।

```elixir
iex> Enum.map_every([1, 2, 3, 4], 2, fn x -> x * 2 end)
[2, 2, 6, 4]
```

### each

কখনো কোন কালেকশন এর উপর ইটারেট কবার দরকার হলে আমরা `each` ব্যাবহার করতে পারি এবং এতে নতুন ভ্যালু তৈরি হয় না।

```elixir
iex> Enum.each(["one", "two", "three"], fn(s) -> IO.puts(s) end)
one
two
three
:ok
```

__Note__: `each` মেথড একটি এটম রিটার্ন করে `:ok`.

### map

যদি আমরা কালেকশন এর প্রতিটি আইটেম এর উপর ফাংশন প্রয়োগ করতে চাই তাহলে `map` মেথড ব্যাবহার করতে পারি।

```elixir
iex> Enum.map([0, 1, 2, 3], fn(x) -> x - 1 end)
[-1, 0, 1, 2]
```

### min

`min/1` কালেকশন থেকে খুঁজে বের করে সবচেয়ে `min` ভ্যালটিু :

```elixir
iex> Enum.min([5, 3, 0, -1])
-1
```

`min/2` ও একই কাজ করে, কিন্তু এটি আমাদের একটি সুযোগ দেয় `Enum` এ একটি ডিফল্ট ভ্যালু দিবার একটি এনয়নিমাস ফাংশন এর ভিতর ।

```elixir
iex> Enum.min([], fn -> :foo end)
:foo
```

### max

`max/1` একটা কালেকশন থেকে `max` ভ্যালু রিটার্ন করে।

```elixir
iex> Enum.max([5, 3, 0, -1])
5
```

আবার `max/2` ও একই রকম কাজ করে কিন্তু এটি `min/2` এর মতন আচরণ করে। এই ফাংশনে আমরা একটা এনয়নিমাস ফাংশন পাঠাতে পারি এবং এতে একটা ডিফল্ট ভ্যালু পাঠাতে পারি।

```elixir
iex> Enum.max([], fn -> :bar end)
:bar
```

### reduce

`reduce` ফাংশন ব্যাবহার করে আমরা কালেকশনকে শুধু মাত্র একটি সিঙ্গেল ভ্যালু বানাতে পারি। এটি করবার জন্য, আমারা একটি অপশনাল একুমেলটর ( `10` এই উদাহরণের জন্য ) পাঠাতে হয়। আর যদি কোন একুমেলটর পাঠানো না হয় তাহলে প্রথম ভ্যালু কে নিয়ে কাজ করা হয়।

```elixir
iex> Enum.reduce([1, 2, 3], 10, fn(x, acc) -> x + acc end)
16
iex> Enum.reduce([1, 2, 3], fn(x, acc) -> x + acc end)
6
iex> Enum.reduce(["a","b","c"], "1", fn(x,acc)-> x <> acc end)
"cba1"
```

### sort

কালেকশন সর্ট করা আমাদের জন্য খুবি সহজ হয়ে গেছে একটি না বরং দুটি `sort` ফাংশন এর জন্য। প্রথমটি এলিক্সির এর টার্ম যা কিনা অর্ডার নির্ধারণ করে নিজে থেকেই।

```elixir
iex> Enum.sort([5, 6, 1, 3, -1, 4])
[-1, 1, 3, 4, 5, 6]

iex> Enum.sort([:foo, "bar", Enum, -1, 4])
[-1, 4, Enum, :foo, "bar"]
```

আরেকটি আমাদের একটি নিজস্ব ফাংশন পাঠানোর সুযোগ করে দেয়।

```elixir
# with our function
iex> Enum.sort([%{:val => 4}, %{:val => 1}], fn(x, y) -> x[:val] > y[:val] end)
[%{val: 4}, %{val: 1}]

# without
iex> Enum.sort([%{:count => 4}, %{:count => 1}])
[%{count: 1}, %{count: 4}]
```

### uniq_by

আমরা `uniq_by/2` ব্যাবহার করে কালেকশন থেকে ডুপ্লিকেশন দুর করতে পারি।

```elixir
iex> Enum.uniq_by([1, 2, 3, 2, 1, 1, 1, 1, 1], fn x -> x end)
[1, 2, 3]
```
এর আগে এই ফাংশন পরিচিত ছিল `uniq/1` নামে। যা কিনা ডেপ্রিকেটেড হয়ে গেছে এলিক্সির ১.৪ হতে কিন্তু এখনো ব্যাবহার যোগ্য ( ওয়ার্নিং এর সাথে )
