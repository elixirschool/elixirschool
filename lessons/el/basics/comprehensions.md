%{
  version: "1.1.0",
  title: "Ανάγνωση Λιστών",
  excerpt: """
  Η ανάγνωση λιστών είναι συντομογραφία για την προσπέλαση συλλογών στην Elixir.  Σε αυτό το μάθημα θα δούμε πως μπορούμε να χρησιμοποιήσουμε τις αναγνώσεις για την επανάληψη και δημιουργία.
  """
}
---

## Βασικά

Συχνά οι αναγνώσεις μπορούν να χρησιμοποιηθούν για να παράγουν πιο συνοπτικές εκφράσεις για τις επαναλήψεις `Enum` και `Stream`.  Ας δούμε μια απλή ανάγνωση και μετά ας την αναλύσουμε:

```elixir
iex> list = [1, 2, 3, 4, 5]
iex> for x <- list, do: x*x
[1, 4, 9, 16, 25]
```

Το πρώτο πράγμα που παρατηρούμε είναι η χρήση της `for` και ενός παραγωγού.  Τι είναι ο παραγωγός; Οι παραγωγοί είναι οι εκφράσεις `x <- [1, 2, 3, 4]` που βρίσκονται στις αναγνώσεις λιστών, είναι υπεύθυνοι για την παραγωγή της επόμενης τιμής.

Είμαστε τυχεροί που οι αναγνώσεις δεν περιορίζονται στις λίστες, στην πράξη δουλεύουν με όλες τις συλλογές:

```elixir
# Λίστες λέξεων κλειδί
iex> for {_key, val} <- [one: 1, two: 2, three: 3], do: val
[1, 2, 3]

# Χάρτες
iex> for {k, v} <- %{"α" => "Α", "β" => "Β"}, do: {k, v}
[{"α", "Α"}, {"β", "Β"}]

# Δυαδικά
iex> for <<c <- "γειά">>, do: <<c>>
["γ", "ε", "ι", "ά"]
```

Όπως πολλά άλλα πράγματα στην Elixir, οι παραγωγοί εξαρτώνται από την αντιπαραβολή προτύπων για να συγκρίνουν την είσοδο που έχει οριστεί στη μεταβλητή στα αριστερά.  Σε περίπτωση που δεν υπάρξει αντιπαραβολή, η τιμή αγνοείται:

```elixir
iex> for {:ok, val} <- [ok: "Γεια σου", error: "Αγνωστε", ok: "Κόσμε"], do: val
["Γεια σου", "Κόσμε"]
```

Είναι πιθανό να χρησιμοποιήσουμε πολλαπλούς παραγωγούς, όπως περίπου στις ένθετες επαναλήψεις:

```elixir
iex> list = [1, 2, 3, 4]
iex> for n <- list, times <- 1..n do
...>   String.duplicate("*", times)
...> end
["*", "*", "**", "*", "**", "***", "*", "**", "***", "****"]
```

Για να παρουσιάσουμε καλύτερα την επανάληψη που προκύπτει, ας χρησιμοποιήσουμε την `IO.puts` για αν εμφανίσουμε τις δύο παραγόμενες τιμές:

```elixir
iex> for n <- list, times <- 1..n, do: IO.puts "#{n} - #{times}"
1 - 1
2 - 1
2 - 2
3 - 1
3 - 2
3 - 3
4 - 1
4 - 2
4 - 3
4 - 4
```

Οι αναγνώσεις λιστών είναι συντομογραφίες και θα πρέπει να χρησιμοποιούνται μόνο όταν πρέπει.

## Φίλτρα

Μπορείτε να σκεφτείτε τα φίλτρα σαν ένα είδος προστάτη για αναγνώσεις.  Όταν μια φιλτραρισμένη τιμή επιστρέφει `false` ή `nil`, εξαιρείται από την τελική λίστα.  Ας κάνουμε μια επανάληψη σε ένα έυρος και να ανησυχήσουμε μόνο για τους ζυγούς αριθμούς. Θα χρησιμοποιήσουμε τη συνάρτηση `is_even/1` από την ενότητα Integer για να ελέγξουμε αν μια τιμή είναι ζυγή ή όχι.

```elixir
import Integer
iex> for x <- 1..10, is_even(x), do: x
[2, 4, 6, 8, 10]
```

Όπως τους παραγωγούς, μπορούμε να χρησιμοποιήσουμε πολλαπλά φίλτρα.  Ας επεκτείνουμε το εύρος και να φιλτράρουμε μόνο τις τιμές που είναι ζυγές και διαρέσιμες με το 3.

```elixir
import Integer
iex> for x <- 1..100,
...>   is_even(x),
...>   rem(x, 3) == 0, do: x
[6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84, 90, 96]
```

## Χρησιμοποίηση της :into

Τι γίνεται αν θέλουμε να παράγουμε κάτι άλλο πέρα από λίστα;  Μπορούμε να το κάνουμε χρησιμοποιώντας την `:into`! Σε γενικές γραμμές η `:into` δέχεται κάθε δομή που υλοποιεί το πρωτόκολο `Collectable`.

Χρησιμοποιώντας την `:into`, ας δημιουργήσουμε ένα χάρτη από μια λίστα λέξεων κλειδί:

```elixir
iex> for {k, v} <- [one: 1, two: 2, three: 3], into: %{}, do: {k, v}
%{one: 1, three: 3, two: 2}
```

Από τη στιγμή που τα αλφαριθμητικά είναι συλλογές μπορούμε να χρησιμοποιήσουμε την ανάγνωση λιστών και την `:into` για να δημιουργήσουμε αλφαριθμητικά:

```elixir
iex> for c <- [72, 101, 108, 108, 111], into: "", do: <<c>>
"Hello"
```

Αυτό ήταν!  Οι αναγνώσεις λιστών είναι ένας έυκολος τρόπος να προσπελάσουμε συλλογές με συνοπτικό τρόπο.
