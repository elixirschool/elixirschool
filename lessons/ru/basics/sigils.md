%{
  version: "1.0.2",
  title: "Строковые метки",
  excerpt: """
  Создание и использование строковых меток.
  """
}
---

## Обзор строковых меток

Elixir предоставляет альтернативный синтаксис для представления литералов и работы с ними.
Строковая метка начинается с тильды `~`, за которой следует символ.
Ядро Elixir уже включает в себя несколько встроенных строковых меток, однако мы можем создавать свои при необходимости расширить возможности языка.

Список доступных строковых меток:

  - `~C` Создаёт список символов **без** экранирования и интерполяции
  - `~c` Создаёт список символов **с** экранированием и интерполяцией
  - `~R` Создаёт регулярное выражение **без** экранирования и интерполяции
  - `~r` Создаёт регулярное выражение **с** экранированием и интерполяцией
  - `~S` Создаёт строку **без** экранирования и интерполяции
  - `~s` Создаёт строку **с** экранированием и интерполяцией
  - `~W` Создаёт список слов  **без** экранирования и интерполяции
  - `~w` Создаёт список слов **с** экранированием и интерполяцией
  - `~N` Создаёт структуру `NaiveDateTime`

Список доступных разделителей:

  - `<...>` Пара угловых скобок
  - `{...}` Пара фигурных скобок
  - `[...]` Пара квадратных скобок
  - `(...)` Пара круглых скобок
  - `|...|` Пара вертикальных черт
  - `/.../` Пара косых черт
  - `"..."` Пара двойных кавычек
  - `'...'` Пара одинарных кавычек

### Список символов

Строковые метки `~c` и `~C` создают списки символов.
Например:

```elixir
iex> ~c/2 + 7 = #{2 + 7}/
'2 + 7 = 9'

iex> ~C/2 + 7 = #{2 + 7}/
'2 + 7 = \#{2 + 7}'
```

Видно, что строчная `~c` интерполирует вычисление, а прописная `~C` &mdash; нет.
Далее мы увидим, что во всех встроенных строковых метках встречается такое разделение на строчные и прописные.

### Регулярные выражения

Строковые метки `~r` и `~R` используются для представления регулярных выражений.
Мы можем создавать их для использования на лету, либо для применения функций `Regex`.
Например:

```elixir
iex> re = ~r/elixir/
~r/elixir/

iex> "Elixir" =~ re
false

iex> "elixir" =~ re
true
```

Как мы видим, в первом тесте на равенство слово `Elixir` не соответствует регулярному выражению.
Дело в том, что оно начинается с заглавной буквы.
Elixir поддерживает регулярные выражения PCRE (Perl Compatible Regular Expressions), поэтому мы можем добавить `i` в конец нашей строковой метки, чтобы отключить регистрозависимость.

```elixir
iex> re = ~r/elixir/i
~r/elixir/i

iex> "Elixir" =~ re
true

iex> "elixir" =~ re
true
```

Также Elixir поддерживает [Regex](https://hexdocs.pm/elixir/Regex.html) API, основанный на библиотеке регулярных выражений из Erlang.
Попробуем воспользоваться `Regex.split/2` на строковой метке регулярного выражения:

```elixir
iex> string = "100_000_000"
"100_000_000"

iex> Regex.split(~r/_/, string)
["100", "000", "000"]
```

Как мы видим, благодаря строковой метке `~r/_/` выражение `"100_000_000"` разделилось на части по символу подчёркивания.
Функция `Regex.split` возвращает список.

### Строка

Строковые метки `~s` и `~S` используются для создания строк.
Например:

```elixir
iex> ~s/the cat in the hat on the mat/
"the cat in the hat on the mat"

iex> ~S/the cat in the hat on the mat/
"the cat in the hat on the mat"
```

Но в чём разница? Отличие такое же, как в строковых метках списка символов,
которые мы уже рассмотрели ранее &mdash; интерполяция и экранирование.
Посмотрим на ещё один пример:

```elixir
iex> ~s/welcome to elixir #{String.downcase "SCHOOL"}/
"welcome to elixir school"

iex> ~S/welcome to elixir #{String.downcase "SCHOOL"}/
"welcome to elixir \#{String.downcase \"SCHOOL\"}"
```

### Список слов

Строковая метка списка слов иногда может оказаться весьма полезной.
Эта возможность упростит код и сэкономит время.
Возьмём простой пример:

```elixir
iex> ~w/i love elixir school/
["i", "love", "elixir", "school"]

iex> ~W/i love elixir school/
["i", "love", "elixir", "school"]
```

Всё, что написано между разделителями, разбивается по пробелу и сохраняется в список.
Однако, с виду между этими примерами нет разницы.
Она вновь заключается в интерполяции и экранировании.
Посмотрим на следующий пример:

```elixir
iex> ~w/i love #{'e'}lixir school/
["i", "love", "elixir", "school"]

iex> ~W/i love #{'e'}lixir school/
["i", "love", "\#{'e'}lixir", "school"]
```

### NaiveDateTime

[NaiveDateTime](https://hexdocs.pm/elixir/NaiveDateTime.html) используется для быстрого создания структуры, представляющей собой `DateTime` **без** часового пояса.

Как правило, стоит избегать создания `NaiveDateTime` напрямую.
Однако это может пригодиться для сопоставления с образцом.
Например:

```elixir
iex> NaiveDateTime.from_iso8601("2015-01-23 23:50:07") == {:ok, ~N[2015-01-23 23:50:07]}
```

## Создание строковых меток

Одной из целей разработки языка Elixir было создать гибкий и расширяемый язык программирования.
Потому неудивительно, что мы можем создавать свои строковые метки.
В этом примере мы создадим строковую метку, которая превращает все символы строки в заглавные.
Так как в ядре Elixir уже есть функция (`String.upcase/1`), то сделаем нашу строковую метку на её основе.

```elixir

iex> defmodule MySigils do
...>   def sigil_u(string, []), do: String.upcase(string)
...> end

iex> import MySigils
nil

iex> ~u/elixir school/
ELIXIR SCHOOL
```

Для начала объявим модуль с именем `MySigils` и внутри него создадим функцию `sigil_u`.
Мы используем `~u`, потому что она не занята в пространстве строковых меток.
`_u` означает, что мы хотим использовать символ `u` после тильды.
Функция должна принимать два аргумента: вводимое значение и список.
