---
version: 1.3.1
title: Коллекции
---

Списки, кортежи, ключевые списки и ассоциативные массивы.

{% include toc.html %}

## Списки

Списки &mdash; это обычные коллекции значений. Они могут включать различные типы и неуникальные значения.

```elixir
iex> [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
```

Списки в Elixir являются односвязными.
Это означает, что получение длины списка имеет линейную сложность (`O(n)`).
По этой причине добавлять элементы в начало списка намного быстрее, чем в конец.

```elixir
iex> list = [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
# Добавление в начало списка (быстро)
iex> ["π" | list]
["π", 3.14, :pie, "Apple"]
# Добавление в конец списка (медленно)
iex> list ++ ["Cherry"]
[3.14, :pie, "Apple", "Cherry"]
```

### Объединение списков

Для объединения списков используется оператор `++/2`:

```elixir
iex> [1, 2] ++ [3, 4, 1]
[1, 2, 3, 4, 1]
```

Небольшая заметка по поводу формата имён (`++/2`), использованного выше:
в Elixir (и Erlang, на основе которого сделан Elixir) имена функций и операторов состоят из двух частей: непосредственно имени (в этом случае `++`) и _арности_.
Арность &mdash; одно из ключевых понятий Elixir и Erlang.
Это количество аргументов, принимаемых функцией (в этом случае два).
Арность и имя соединены через слэш. Позже мы разберём это подробнее.

### Вычитание списков

Оператор `--/2` предоставляет возможность вычитать списки. Не будет ошибкой вычитание отсутствующего элемента:

```elixir
iex> ["foo", :bar, 42] -- [42, "bar"]
["foo", :bar]
```

Обратите внимание на повторяющиеся значения.
Из левого списка удаляется только первое вхождение каждого элемента правого списка:

```elixir
iex> [1,2,2,3,2,3] -- [1,2,3,2]
[2, 3]
```

**Замечание:** Для сопоставления элементов используется [строгое сравнение](../basics#section-11). Например:

```elixir
iex> [2] -- [2.0]
[2]
iex> [2.0] -- [2.0]
[]
```

### Голова / Хвост

При использовании списков очень частой операцией является получение "головы" и "хвоста" списка.
"Головой" является первый элемент, а "хвостом" &mdash; остальные элементы.
Для работы с ними Elixir предоставляет два оператора &mdash; `hd` и `tl`:

```elixir
iex> hd [3.14, :pie, "Apple"]
3.14
iex> tl [3.14, :pie, "Apple"]
[:pie, "Apple"]
```

Того же результата можно добиться с использованием оператора cons &mdash; `|`. Мы будем часто его встречать в последующих уроках.

```elixir
iex> [head | tail] = [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
iex> head
3.14
iex> tail
[:pie, "Apple"]
```

## Кортежи

Кортежи похожи на списки, но хранятся в памяти последовательно.
Это даёт возможность быстро получить определенный элемент и длину кортежа. Но изменения становятся "дорогими", так как для этого создаваемый кортеж должен быть целиком скопирован в новую область памяти.
Кортежи определяются с помощью фигурных скобок:

```elixir
iex> {3.14, :pie, "Apple"}
{3.14, :pie, "Apple"}
```

Часто они используются как механизм для получения дополнительной информации из функций. Полезность этого будет видна позже, когда мы будем углубляться в [сопоставление с образцом](../pattern-matching/):

```elixir
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}
iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

## Ключевые списки

Ключевые списки и ассоциативные массивы являются имплементациями ассоциативных коллекций в Elixir.
В Elixir ключевые списки &mdash; это специальные списки из двухэлементных кортежей, первым элементом которых является атом. По скорости они идентичны спискам.

```elixir
iex> [foo: "bar", hello: "world"]
[foo: "bar", hello: "world"]
iex> [{:foo, "bar"}, {:hello, "world"}]
[foo: "bar", hello: "world"]
```

Три характеристики этой структуры данных показывают её важность:

+ Ключи являются атомами.
+ Ключи имеют свой порядок.
+ Ключи необязательно должны быть уникальными.

Поэтому она часто используется для передачи параметров в функции.

## Ассоциативные массивы

В Elixir ассоциативный массив &mdash; это хранилище типа ключ-значение с возможностью быстрого получения информации по ключу.
В отличие от ключевых списков, они поддерживают любой тип ключей и не сохраняют порядок следования.
Ассоциативный массив объявляется с помощью синтаксиса `%{}`:

```elixir
iex> map = %{:foo => "bar", "hello" => :world}
%{:foo => "bar", "hello" => :world}
iex> map[:foo]
"bar"
iex> map["hello"]
:world
```

С версии Elixir 1.2 переменные поддерживаются в качестве ключей:

```elixir
iex> key = "hello"
"hello"
iex> %{key => "world"}
%{"hello" => "world"}
```

Если в эту структуру данных добавляется новый ключ, он перепишет старое значение:

```elixir
iex> %{:foo => "bar", :foo => "hello world"}
%{foo: "hello world"}
```

Как видно из вывода команды выше, также есть специальный короткий синтаксис для ассоциативных массивов, ключами которых являются только атомы:

```elixir
iex> %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> %{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}
true
```

Также существует специальный синтаксис для получения значений ключей-атомов:

```elixir
iex> map = %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> map.hello
"world"
```

Ещё одно интересное свойство ассоциативных массивов &mdash; это особенный синтаксис для обновления:

```elixir
iex> map = %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> %{map | foo: "baz"}
%{foo: "baz", hello: "world"}
```

**Примечание**: такой синтаксис работает только для обновления существующих ключей в ассоциативных массивах! Если указанного ключа нет, возникнет исключение `KeyError`.

Для создания нового ключа используйте [`Map.put/3`](https://hexdocs.pm/elixir/Map.html#put/3)

```elixir
iex> map = %{hello: "world"}
%{hello: "world"}
iex> %{map | foo: "baz"}
** (KeyError) key :foo not found in: %{hello: "world"}
    (stdlib) :maps.update(:foo, "baz", %{hello: "world"})
    (stdlib) erl_eval.erl:259: anonymous fn/2 in :erl_eval.expr/5
    (stdlib) lists.erl:1263: :lists.foldl/3
iex> Map.put(map, :foo, "baz")
%{foo: "baz", hello: "world"}
```
