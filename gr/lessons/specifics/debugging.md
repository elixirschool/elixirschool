---
version: 1.0.1
title: Debugging
---

Τα σφάλματα είναι αναπόσπαστο μέρος κάθε project, γιαυτό και χρειαζόμστε απασφαλμάτωση. Σε αυτό το μάθημα θα μάθουμε για την απασφαλμάτωση κώδικα στην Elixir καθώς και για τα εργαλεία στατικής ανάλυσης που μας βοηθάνε να βρούμε πιθανά σφάλματα.

{% include toc.html %}

# Dialyxir και Dialyzer

Το [Dialyzer](http://erlang.org/doc/man/dialyzer.html), ένας διαφορικός αναλυτής για προγράμματα Erlang είναι ένα εργαλείο για στατική ανάλυση κώδικα. Με άλλα λόγια _διαβάζουν_ αλλά δεν _τρέχουν_ κώδικα και τον αναλύουν π.χ. ψάχνοντας για κάποια σφάλματα, νεκρό, αχρείαστο ή απροσπέλαστο κώδικα.

Το [Dialyxir](https://github.com/jeremyjh/dialyxir) είνα μια εργασία mix που απλοποιεί τη χρήση του Dialyzer στην Elixir.

Οι προδιαγραφές βοηθούν εργαλεία όπως το Dialyzer να καταλάβουν τον κώδικα καλύτερα. Αντίθετα με την τεκμηρίωση που είναι αναγνώσιμη και κατανοητή μόνο από άλλους ανθρώπους (αν υπάρχει και είναι καλογραμμένη), η `spec` χρησιμοποιεί πιο επίσημο συντακτικό και μπορεί να γίνει κατανοητή από μια μηχανή.

Ας προσθέσουμε το Dialyzer στο project μας. Ο πιο απλός τρόπος είναι να προσθέσουμε την εξάρτηση στο αρχείο `mix.exs`:

```elixir
defp deps do
  [{:dialyxir, "~> 0.4", only: [:dev]}]
end
```

Τότε καλούμε:

```shell
$ mix deps.get
...
$ mix deps.compile
```

Η πρώτη εντολή θα κατεβάσει και εγκαταστήσει το Dialyxir. Μπορεί να σας ζητηθεί να εγκαταστήσετε το Hex μαζί του. Το δεύτερο συντάσσει την εφαρμογή Dialyxir. Αν θέλετε να εγκαταστήσετε το Dialyxir καθολικά, παρακαλώ διαβάστε την [τεκμηρίωσή του](https://github.com/jeremyjh/dialyxir#installation).

Το τελευταίο βήμα είναι να τρέξετε το Dialyzer για να χτίσετε ξανά το PLT(Persistent Lookup Table - Πίνακας Μόνιμης Εύρεσης). Πρέπει να το κάνετε αυτό κάθε φορά που εγκαθιστάτε μια νέα έκδοση Erlang ή Elixir. Ευτυχώς, το Dialyzer δεν θα προσπαθήσει να αναλύσει τη βασική βιβλιοθήκη κάθε φορά που προσπαθείτε να το χρησιμοποιήσετε. Χρειάζονται μερικά λεπτά για να ολοκληρωθεί η λήψη.

```shell
$ mix dialyzer --plt
Starting PLT Core Build ... this will take awhile
dialyzer --build_plt --output_plt /.dialyxir_core_18_1.3.2.plt --apps erts kernel stdlib crypto public_key -r /Elixir/lib/elixir/../eex/ebin /Elixir/lib/elixir/../elixir/ebin /Elixir/lib/elixir/../ex_unit/ebin /Elixir/lib/elixir/../iex/ebin /Elixir/lib/elixir/../logger/ebin /Elixir/lib/elixir/../mix/ebin
  Creating PLT /.dialyxir_core_18_1.3.2.plt ...
...
 done in 5m14.67s
done (warnings were emitted)
```

## Στατική ανάλυση κώδικα

Τώρα είμαστε έτοιμοι να χρησιμοποιήσουμε το Dialyxir:

```shell
$ mix dialyzer
...
examples.ex:3: Invalid type specification for function 'Elixir.Examples':sum_times/1. The success typing is (_) -> number()
...
```

Το μήνυμα από το Dialyzer είναι ξεκάθαρο: ο τύπος επιστροφής της συνάρτησής μας `sum_times/1` είναι διαφορετικός από αυτόν που έχει οριστεί. Αυτό συμβαίνει γιατί η `Enum.sum/1` επιστρέφει έναν `αριθμό` και όχι έναν `ακέραιο` αλλά ο τύπος επιστροφής της `sum_times/1` είναι `ακέραιος`.

Από τη στιγμή που ο `αριθμός` δεν είναι το ίδιο πράγμα με τον `ακέραιο` δεχόμαστε ένα σφάλμα. Πως θα το διορθώσουμε; Πρέπει να χρησιμοποιήσουμε την συνάρτηση `round/1` για να αλλάξουμε τον `αριθμό` σε έναν `ακέραιο`:

```elixir
@spec sum_times(integer) :: integer
def sum_times(a) do
  [1, 2, 3]
  |> Enum.map(fn el -> el * a end)
  |> Enum.sum()
  |> round
end
```

Τελικά:

```shell
$ mix dialyzer
...
  Proceeding with analysis... done in 0m0.95s
done (passed successfully)
```

Η χρήση των προδιαγραφών μαζί με εργαλεία ανάλυσης στατικού κώδικα μας βοηθάει να γράφουμε κώδικα που είναι αυτό-ελεγμένος και περιέχει λιγότερα σφάλματα.

# Απασφαλμάτωση

Μερικές φορές η στατική ανάλυση του κώδικα δεν είναι αρκετή. Μπορεί να είναι αναγκαίο να καταλάβουμε τη ροή εκτέλεσης ώστε να βρούμε σφάλματα. Ο απλούστερος τρόπος είναι να βάλουμε εκφράσεις εξόδου στον κώδικά μας όπως η `IO.puts/2` για να παρακολουθήσουμε τιμές και ροή κώδικα, αλλά αυτή η τεχνική είναι απαρχαιωμένη και έχει όρια. Ευτυχώς για εμάς, μπορούμε να χρησιμοποιήσουμε τον εντοπιστή σφαλμάτων της Erlang για να απασφαλματώσουμε τον κώδικά μας στην Elixir.

Ας δούμε μια βασική ενότητα:

```elixir
defmodule Example do
  def cpu_burns(a, b, c) do
    x = a * 2
    y = b * 3
    z = c * 5

    x + y + z
  end
end
```

Και τώρα τρέξτε το `iex`:

```bash
$ iex -S mix
```

Και τώρα τρέξτε τον εντοπιστή σφαλμάτων:

```elixir
iex > :debugger.start()
{:ok, #PID<0.307.0>}
```

Η ενότητα `:debugger` της Erlang παρέχει πρόσβαση στον εντοπιστή σφαλμάτων. Μπορούμε να χρησιμοποιήσουμε την `start/1` για να τον παραμετροποιήσουμε:

+ Ένα εξωτερικό αρχείο παραμετροποίησης μπορεί να χρησιμοποιηθεί περνώντας την διαδρομή αρχείου.
+ Αν το όρισμα είναι `:local` ή `:global` τότε ο εντοπιστής θα:
    + `:global` - ερμηνεύσει τον κώδικα σε όλους τους γνωστούς κόμβους. Αυτή είναι η προκαθορισμένη τιμή.
    + `:local` - ερμηνεύσει τον κώδικα μόνο στον τρέχοντα κόμβο.

Το επόμενο βήμα είναι να συνδέσουμε την ενότητά μας στον εντοπιστή σφαλμάτων:

```elixir
iex > :int.ni(Example)
{:module, Example}
```

Η ενότητα `:int` είναι ένας ερμηνευτής που μας δίνει τη δυνατότητα να δημιουργούμε σημεία διακοπής και να μπούμε μέσα στην εκτέλεση του κώδικα.

Όταν ξεκινάτε τον εντοπιστή σφαλμάτων θα δείτε ένα νέο παράθυρο σαν αυτό:

![Στιγμιότυπο οθόνης Εντοπιστή Σφαλμάτων 1]({% asset_path "debugger_1.png" %})

Αφού συνδέσουμε την ενότητά μας στον εντοπιστή σφαλμάτων θα είναι διαθέσιμη στο μενού στα αριστερά μας:

![Στιγμιότυπο οθόνης Εντοπιστή Σφαλμάτων 2]({% asset_path "debugger_2.png" %})

## Δημιουργία σημείων διακοπής

Ένα σημείο διακοπής είναι ένα σημείο στον κώδικα όπου η εκτέλεση μπορεί να διακοπεί. Έχουμε δύο τρόπους δημιουργίας σημείων διακοπής:

+ `:int.break/2` in our code
+ The debugger's UI

Ας προσπαθήσουμε να δημιουργήσουμε ένα σημείο διακοπής στο IEx:

```elixir
iex > :int.break(Example, 8)
:ok
```

Αυτό ορίζει ένα σημείο διακοπής στη γραμμή 8 της ενότητας `Example`. Τώρα όταν καλέσουμε τη συνάρτησή μας:

```elixir
iex > Example.cpu_burns(1, 1, 1)
```

Η εκτέλεση θα διακοπεί στο IEx και το παράθυρο εντοπισμού σφαλμάτων θα πρέπει να δείχνει κάπως έτσι: 

![Στιγμιότυπο οθόνης Εντοπιστή Σφαλμάτων 3]({% asset_path "debugger_3.png" %})

Ένα επιπρόσθετο παράθυρο με τον πηγαίο κώδικά μας θα εμφανιστεί:

![Στιγμιότυπο οθόνης Εντοπιστή Σφαλμάτων 4]({% asset_path "debugger_4.png" %})

Σε αυτό το παράθυρο μπορούμε να δούμε την τιμή των μεταβλητών, να προχωρήσουμε στην επόμενη γραμμή ή να αξιολογήσουμε τις εκφράσεις. Η `:int.disable_break/2` μπορεί να κληθεί ώστε να απενεργοποιήσουμε ένα σημείο διακοπής:

```elixir
iex > :int.disable_break(Example, 8)
:ok
```

Για να ενεργοποιήσουμε ξανά ένα σημείο διακοπής μπορούμε να καλέσουμε την `:int.enable_break/2` ή μπορούμε να διαγράψουμε ένα σημείο διακοπής με αυτό τον τρόπο:

```elixir
iex > :int.delete_break(Example, 8)
:ok
```

Οι ίδιες λειτουργίες είναι διαθέσιμες στο παράθυρο του εντοπιστή σφαλμάτων. Στο κεντρικό μενού, __Break__, μπορούμε να επιλέξουμε __Line Break__ και να ορίσουμε σημεία διακοπής. Αν επιλέξουμε μια γραμμή που δεν έχει κώδικα τότε το σημείο διακοπής θα αγνοηθεί, αλλά θα εμφανιστεί στο παράθυρο του εντοπιστή σφαλμάτων. Υπάρχουν τρείς τύποι σημείων διακοπής:

+ Σημεία διακοπής γραμμής - ο εντοπιστής διακόπτει την εκτέλεση μόλις φτάσουμε στη γραμμή, ορισμός με την `:int.break/2`
+ Προαιρετικά σημεία διακοπής - παρόμοια με τα σημεία διακοπής γραμμής αλλά ο εντοπιστής σφαλμάτων διακόπτει μόνο όταν πραγματοποιηθεί μια συγκεκριμένη συνθήκη, ορίζονται με την `:int.get_binding/2`
+ Σηείο διακοπής συνάρτησης - ο εντοπιστής θα διακόψει στην πρώτη γραμμή μιας συνάρτησης, ορισμένης με τη χρήση της `:int.break_in/3`

Αυτό ήταν όλο! Καλή απασφαλμάτωση!
