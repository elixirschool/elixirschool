---
version: 1.2.3
title: Колекції
---

Списки, кортежі, ключові списки та асоціативні масиви.

{% include toc.html %}

## Списки
Списки &mdash; це звичайні колекції значень. Вони можуть включати різні типи та неунікальні значення.

```elixir
iex> [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
```

Списки в Elixir є однобічно зв'язними. Це означає, що отримання довжини списку - операція, яка буде виконана за лінійний час `O(n)`. По цій причині додавати елементи до початку списку набагато швидше, ніж в його кінець.

```elixir
iex> list = [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
# Додавати в початок (швидко)
iex> ["π"] ++ list
["π", 3.14, :pie, "Apple"]
# Додавати в кінець (довго)
iex> list ++ ["Cherry"]
[3.14, :pie, "Apple", "Cherry"]
```

### Об'єднання списків

Для об'єднання списків використовується оператор `++/2`:

```elixir
iex> [1, 2] ++ [3, 4, 1]
[1, 2, 3, 4, 1]
```

Невелика замітка щодо формату імен (`++/2`), який використовувався вище: в Elixir (та й Erlang, на основі якого створений Elixir) імена функцій та операторів складаються з двох частин: безпосередньо імені (в цьому випадку `++`) та _арності_. Арність &mdash; одне з ключових понять Elixir та Erlang. Це кількість аргументів, які приймає функція (в цьому випадку два). Арність та ім'я поєднуються через слеш. Пізніше ми розберемо це детальніше.

### Віднімання списків

Оператор `--/2` дає можливість віднімати списки. Не буде помилкою віднімання неіснуючого елемента:

```elixir
iex> ["foo", :bar, 42] -- [42, "bar"]
["foo", :bar]
```

Зверніть увагу на повторні значення. З лівого списку видаляється тільки перше входження кожного елемента правого списку:

```elixir
iex> [1,2,2,3,2,3] -- [1,2,3,2]
[2, 3]
```

**Зауваження:** Для порівняння елементів використовується [строге порівняння](../basics#Порівняння).

### Голова / Хвіст

При використанні списків дуже частою операцією є отримання "голови" та "хвоста" списку. "Головою" є перший елемент, а "хвостом" &mdash; усі інші елементи. Для роботи з ними Elixir надає два оператори &mdash; `hd` та `tl`:

```elixir
iex> hd [3.14, :pie, "Apple"]
3.14
iex> tl [3.14, :pie, "Apple"]
[:pie, "Apple"]
```

Того ж результату можливо досягти використовуючи оператор cons &mdash; `|`. Ми будемо часто його зустрічати в наступних уроках.

```elixir
iex> [head | tail] = [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
iex> head
3.14
iex> tail
[:pie, "Apple"]
```

## Кортежі

Кортежі схожі на списки, але зберігаються в пам'яті послідовно. Це дає можливість швидко отримати певний елемент та довжину кортежу. Але зміни стають "дорогими", так як для цього новостворений кортеж повинен бути повністю копійованим у нову область пам'яті. Кортежі створюються за допомогою фігурних дужок:

```elixir
iex> {3.14, :pie, "Apple"}
{3.14, :pie, "Apple"}
```

Часто вони використовуються як механізм для отримання додаткової інформації з функцій. Користь з цього буде видна пізніше, коли ми будемо заглиблюватися у [зіставлення зі зразком](../pattern-matching/):

```elixir
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}
iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

## Ключові списки

Ключові списки та асоціативні масиви є імплементаціями асоціативних колекцій в Elixir. В Elixir ключові списки &mdash; це спеціальні списки з двоелементних кортежів, першим елементом яких є атом. По швидкості вони ідентичні спискам.

```elixir
iex> [foo: "bar", hello: "world"]
[foo: "bar", hello: "world"]
iex> [{:foo, "bar"}, {:hello, "world"}]
[foo: "bar", hello: "world"]
```

Три характеристики цієї структури даних показують її важливість:

+ Ключі є атомами.
+ Ключі мають свій порядок.
+ Ключі неунікальні.

Тому вона часто використовується для передачі параметрів у функції.

## Асоціативні масиви

В Elixir асоціативний масив &mdash; це сховище типу ключ-значення з можливістю швидкого отримання інформації по ключу. На відміну від ключових списків, вони підтримують будь-який тип ключів і не зберігають порядок слідування. Асоціативний масив об'являється за допомогою синтаксису `%{}`:

```elixir
iex> map = %{:foo => "bar", "hello" => :world}
%{:foo => "bar", "hello" => :world}
iex> map[:foo]
"bar"
iex> map["hello"]
:world
```

З версії Elixir 1.2 змінні підтримуються у якості ключів:

```elixir
iex> key = "hello"
"hello"
iex> %{key => "world"}
%{"hello" => "world"}
```

Якщо в цю структуру даних додається новий ключ, він перепише старе значення:

```elixir
iex> %{:foo => "bar", :foo => "hello world"}
%{foo: "hello world"}
```

Як видно з виводу команди вище, існує спеціальний короткий синтаксис для асоціативних масивів, ключами яких є тільки атоми:

```elixir
iex> %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}

iex> %{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}
true
```

Також існує спеціальний синтаксис для отримання значень ключів-атомів:

```elixir
iex> map = %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> map.hello
"world"
```

Ще одна цікава особливість асоціативних масивів &mdash; це особливий синтаксис для оновлення:

```elixir
iex> map = %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> %{map | foo: "baz"}
%{foo: "baz", hello: "world"}
```
